diff -rupN original/proton/session/api.py proton/session/api.py
--- original/proton/session/api.py	2023-07-24 11:01:59.000000000 +0700
+++ proton/session/api.py	2023-07-24 09:55:53.047106877 +0700
@@ -20,7 +20,8 @@ from __future__ import annotations
 from typing import *
 
 from proton import session
-from .exceptions import ProtonCryptoError, ProtonAPIError, ProtonAPIAuthenticationNeeded, ProtonAPI2FANeeded, ProtonAPIMissingScopeError, ProtonAPIHumanVerificationNeeded
+from .exceptions import ProtonCryptoError, ProtonAPIError, ProtonAPIAuthenticationNeeded, ProtonAPI2FANeeded, \
+    ProtonAPIMissingScopeError, ProtonAPIHumanVerificationNeeded
 from .srp import User as PmsrpUser
 from .environments import Environment
 from ..loader import Loader
@@ -54,18 +55,21 @@ def sync_wrapper(f):
             newloop = True
 
         if not newloop:
-            raise RuntimeError("It's forbidden to call sync_wrapped functions from an async one, please await directly the async one")
-        
+            raise RuntimeError(
+                "It's forbidden to call sync_wrapped functions from an async one, please await directly the async one")
+
         loop = asyncio.new_event_loop()
         try:
             return loop.run_until_complete(f(*a, **kw))
         finally:
             loop.close()
+
     wrapped_f.__doc__ = f"Synchronous wrapper for :meth:`{f.__name__}`"
     return wrapped_f
 
+
 class Session:
-    def __init__(self, appversion : str = "Other", user_agent:str="None"):
+    def __init__(self, appversion: str = "Other", user_agent: str = "None"):
         """Get a session towards the Proton API.
 
         :param appversion: version for the new Session object, defaults to ``"Other"``
@@ -87,37 +91,36 @@ class Session:
 
         self.__AccountName = None
 
-        #Extra data that we want to persist (used if we load a session from a subclass)
+        # Extra data that we want to persist (used if we load a session from a subclass)
         self.__extrastate = {}
 
         # Temporary storage for 2FA object
         self.__2FA = None
 
-        #Refresh revision (incremented each time a refresh is done)
-        #This allows knowing if a refresh should be done or if it is already in progress
+        # Refresh revision (incremented each time a refresh is done)
+        # This allows knowing if a refresh should be done or if it is already in progress
         self.__refresh_revision = 0
 
-        #Lazy initialized by modulus decryption
+        # Lazy initialized by modulus decryption
         self.__gnupg_for_modulus = None
 
-        #Lazy initialized by api request
+        # Lazy initialized by api request
         self.__transport = None
         self.__transport_factory = None
 
         self.transport_factory = None
 
-        #Lazy initialized by request lock/unlock
+        # Lazy initialized by request lock/unlock
         self.__can_run_requests = None
 
-        #Lazy initialized by environment:
+        # Lazy initialized by environment:
         self.__environment = None
 
         self.__persistence_observers = []
 
-
     async def async_api_request(self, endpoint,
-        jsondata=None, data=None, additional_headers=None,
-        method=None, params=None, no_condition_check=False):
+                                jsondata=None, data=None, additional_headers=None,
+                                method=None, params=None, no_condition_check=False):
         """Do an API request.
 
         This call can return any of the exceptions defined in :mod:`proton.session.exceptions`.
@@ -152,7 +155,8 @@ class Session:
             attempts -= 1
             try:
                 refresh_revision_at_start = self.__refresh_revision
-                return await self.__async_api_request_internal(endpoint, jsondata, data, additional_headers, method, params, no_condition_check)
+                return await self.__async_api_request_internal(endpoint, jsondata, data, additional_headers, method,
+                                                               params, no_condition_check)
             except ProtonAPIError as e:
                 # We have a missing scope.
                 if e.http_code == 403:
@@ -162,31 +166,33 @@ class Session:
                     else:
                         # Otherwise, just throw the 403
                         raise ProtonAPIMissingScopeError.from_proton_api_error(e)
-                #401: token expired
+                # 401: token expired
                 elif e.http_code == 401:
-                    #If we can refresh, than do it and retry
-                    if await self.async_refresh(only_when_refresh_revision_is=refresh_revision_at_start, no_condition_check=no_condition_check):
+                    # If we can refresh, than do it and retry
+                    if await self.async_refresh(only_when_refresh_revision_is=refresh_revision_at_start,
+                                                no_condition_check=no_condition_check):
                         continue
-                    #Else, fail :-(
+                    # Else, fail :-(
                     else:
                         raise ProtonAPIAuthenticationNeeded.from_proton_api_error(e)
-                #422 + 9001: Human verification needed
+                # 422 + 9001: Human verification needed
                 elif e.http_code == 422 and e.body_code == 9001:
                     raise ProtonAPIHumanVerificationNeeded.from_proton_api_error(e)
-                #Invalid human verification token
+                # Invalid human verification token
                 elif e.body_code == 12087:
                     raise ProtonAPIHumanVerificationNeeded.from_proton_api_error(e)
-                #These are codes which require and immediate retry
+                # These are codes which require and immediate retry
                 elif e.http_code in (408, 502):
                     continue
-                #These not, let's retry more gracefully
+                # These not, let's retry more gracefully
                 elif e.http_code in (429, 503):
                     await self.__sleep_for_exception(e)
                     continue
-                #Something else, throw
+                # Something else, throw
                 raise
 
-    async def async_authenticate(self, username: str, password: str, client_secret: str = None, no_condition_check: bool = False, additional_headers=None) -> bool:
+    async def async_authenticate(self, username: str, password: str, client_secret: str = None,
+                                 no_condition_check: bool = False, additional_headers=None) -> bool:
         """Authenticate against Proton API
 
         :param username: Proton account username
@@ -267,9 +273,7 @@ class Session:
         finally:
             self._requests_unlock(no_condition_check)
 
-    
-
-    async def async_provide_2fa(self, code : str, no_condition_check=False, additional_headers=None) -> bool:
+    async def async_provide_2fa(self, code: str, no_condition_check=False, additional_headers=None) -> bool:
         """Provide Two Factor Authentication Code to the API.
         
         :param code: 2FA code
@@ -289,12 +293,12 @@ class Session:
             if ret.get('Code') == 1000:
                 self.__2FA = None
                 return True
-            
+
             return False
         except ProtonAPIError as e:
             if e.body_code == 8002:
                 # 2FA jail, we need to start over (beware, we might hit login jails too)
-                #Needs re-login
+                # Needs re-login
                 self._clear_local_data()
                 raise ProtonAPIAuthenticationNeeded.from_proton_api_error(e)
             if e.http_code == 401:
@@ -315,12 +319,12 @@ class Session:
         """
         self._requests_lock(no_condition_check)
 
-        #If we have the correct revision, and it doesn't match, then just exit
+        # If we have the correct revision, and it doesn't match, then just exit
         if only_when_refresh_revision_is is not None and self.__refresh_revision != self.__refresh_revision:
             self._requests_unlock(no_condition_check)
             return True
 
-        #Increment the refresh revision counter, so we don't refresh multiple times
+        # Increment the refresh revision counter, so we don't refresh multiple times
         self.__refresh_revision += 1
 
         attempts = 3
@@ -341,24 +345,22 @@ class Session:
                     return True
 
                 except ProtonAPIError as e:
-                    #https://confluence.protontech.ch/display/API/Authentication%2C+sessions%2C+and+tokens#Authentication,sessions,andtokens-RefreshingSessions
+                    # https://confluence.protontech.ch/display/API/Authentication%2C+sessions%2C+and+tokens#Authentication,sessions,andtokens-RefreshingSessions
                     if e.http_code == 409:
-                        #409 Conflict - Indicates a race condition on the DB, and the request should be performed again
+                        # 409 Conflict - Indicates a race condition on the DB, and the request should be performed again
                         continue
-                    #We're probably jailed, just retry later
+                    # We're probably jailed, just retry later
                     elif e.http_code in (429, 503):
                         await self.__sleep_for_exception(e)
                         continue
                     elif e.http_code in (400, 422):
-                        #Needs re-login
+                        # Needs re-login
                         self._clear_local_data()
                         return False
                     return False
         finally:
             self._requests_unlock(no_condition_check)
 
-
-
     async def async_logout(self, no_condition_check=False, additional_headers=None):
         """Logout from API.
         
@@ -403,24 +405,24 @@ class Session:
             return True
         finally:
             self._requests_unlock(no_condition_check)
-        #FIXME: clear user keys
+        # FIXME: clear user keys
 
-    #FIXME: implement unlock
+    # FIXME: implement unlock
 
     async def async_human_verif_request_code(self, address=None, phone=None, additional_headers=None):
         """Request a verification code. Either address (email address) or phone (phone number) should be specified."""
-        assert address is not None ^ phone is not None # nosec (we use email validation by default if both are provided, but it's not super clean if the dev doesn't know about it)
+        assert address is not None ^ phone is not None  # nosec (we use email validation by default if both are provided, but it's not super clean if the dev doesn't know about it)
 
         if address is not None:
             data = {'Type': 'email', 'Destination': {'Address': address}}
         elif phone is not None:
             data = {'Type': 'sms', 'Destination': {'Phone': phone}}
-        
-        return await self.async_api_request('/users/code', data, additional_headers=additional_headers).get('Code', 0) == 1000
+
+        return await self.async_api_request('/users/code', data, additional_headers=additional_headers).get('Code',
+                                                                                                            0) == 1000
 
     async def async_human_verif_provide_token(self, method, token):
         pass
-    
 
     # Wrappers to provide non-asyncio API
     api_request = sync_wrapper(async_api_request)
@@ -496,7 +498,7 @@ class Session:
         :rtype: bool
         """
         return self.__UID is not None
-    
+
     @property
     def UID(self) -> Optional[str]:
         """:return: the session UID, None if not authenticated
@@ -560,17 +562,18 @@ class Session:
         if not isinstance(newvalue, Environment):
             raise TypeError("environment should be a subclass of Environment")
 
-        #Same environment => nothing to do
+        # Same environment => nothing to do
         if self.__environment == newvalue:
             return
-        
+
         if self.__environment is not None:
             raise ValueError("Cannot change environment of an established session (that would create security issues)!")
         self.__environment = newvalue
 
     def __setstate__(self, data):
         # If we're running an unpickle, then the object constructor hasn't been called, so we need to populate __dict__
-        for attr, default in (('gnupg_for_modulus', None), ('can_run_requests', None), ('transport', None), ('persistence_observers', [])):
+        for attr, default in (
+        ('gnupg_for_modulus', None), ('can_run_requests', None), ('transport', None), ('persistence_observers', [])):
             if '_Session__' + attr not in self.__dict__:
                 self.__dict__['_Session__' + attr] = default
 
@@ -578,7 +581,7 @@ class Session:
         for attr, default in (('2FA', None), ('appversion', 'Other'), ('user_agent', 'None'), ('refresh_revision', 0)):
             if '_Session__' + attr not in self.__dict__:
                 self.__dict__['_Session__' + attr] = data.get('LastUseData', {}).get(attr, default)
-        
+
         # We don't pickle the transport, so if not set just use the default
         if '_Session__transport_factory' not in self.__dict__:
             self.transport_factory = None
@@ -588,16 +591,17 @@ class Session:
         self.__RefreshToken = data.get('RefreshToken', None)
         self.__Scopes = data.get('Scopes', None)
         self.__AccountName = data.get('AccountName', None)
-        #Reset transport (user agent etc might have changed)
+        # Reset transport (user agent etc might have changed)
         self.__transport = None
-        #get environment as stored in the session
+        # get environment as stored in the session
         if data.get('Environment', None) is not None:
             self.__environment: Environment = Loader.get("environment", data.get('Environment', None))()
         else:
             self.__environment = None
 
         # Store everything we don't know about in extrastate
-        self.__extrastate = dict([(k, v) for k, v in data.items() if k not in ('UID','AccessToken','RefreshToken','Scopes','AccountName','Environment', 'LastUseData')])
+        self.__extrastate = dict([(k, v) for k, v in data.items() if k not in (
+        'UID', 'AccessToken', 'RefreshToken', 'Scopes', 'AccountName', 'Environment', 'LastUseData')])
 
     def __getstate__(self):
         # If we don't have an UID, then we're not logged in and we don't want to store a specific state
@@ -605,7 +609,7 @@ class Session:
             data = {}
         else:
             data = {
-                #Session data
+                # Session data
                 'UID': self.UID,
                 'AccessToken': self.__AccessToken,
                 'RefreshToken': self.__RefreshToken,
@@ -635,7 +639,7 @@ class Session:
         """
         if no_condition_check:
             return
-        
+
         if self.__can_run_requests is None:
             self.__can_run_requests = asyncio.Event()
         self.__can_run_requests.clear()
@@ -657,7 +661,7 @@ class Session:
         """
         if no_condition_check:
             return
-        
+
         if self.__can_run_requests is None:
             self.__can_run_requests = asyncio.Event()
         self.__can_run_requests.set()
@@ -683,20 +687,19 @@ class Session:
         """
         if no_condition_check or self.__can_run_requests is None:
             return
-        
-        await self.__can_run_requests.wait()
 
+        await self.__can_run_requests.wait()
 
     async def __sleep_for_exception(self, e):
-        if e.http_headers.get('retry-after','-').isnumeric():
+        if e.http_headers.get('retry-after', '-').isnumeric():
             await asyncio.sleep(int(e.http_headers.get('retry-after')))
         else:
-            await asyncio.sleep(3+random.random()*5) # nosec (no crypto risk here of using an unsafe generator)
+            await asyncio.sleep(3 + random.random() * 5)  # nosec (no crypto risk here of using an unsafe generator)
 
     async def __async_api_request_internal(
-        self, endpoint,
-        jsondata=None, data=None, additional_headers=None,
-        method=None, params=None, no_condition_check=False
+            self, endpoint,
+            jsondata=None, data=None, additional_headers=None,
+            method=None, params=None, no_condition_check=False
     ):
         """Internal function to do an API request (without clever exception handling and retrying). 
         See :meth:`async_api_request` for the parameters specification."""
@@ -724,7 +727,3 @@ class Session:
             raise ProtonCryptoError('Invalid modulus')
 
         return base64.b64decode(verified.data.strip())
-
-
-
-
diff -rupN original/proton/vpn/app/gtk/services/refresher/session_refresher.py proton/vpn/app/gtk/services/refresher/session_refresher.py
--- original/proton/vpn/app/gtk/services/refresher/session_refresher.py	1970-01-01 07:00:00.000000000 +0700
+++ proton/vpn/app/gtk/services/refresher/session_refresher.py	2023-07-24 09:55:53.035106836 +0700
@@ -0,0 +1,69 @@
+import logging
+from datetime import timedelta
+
+from gi.repository import GLib, GObject
+from concurrent.futures import Future, ThreadPoolExecutor
+
+from proton.vpn.app.gtk.utils.glib import run_after_seconds
+from proton.vpn.core_api.api import ProtonVPNAPI
+
+logger = logging.getLogger(__name__)
+
+
+class SessionRefresher(GObject.Object):
+
+    def __init__(
+            self,
+            thread_pool_executor: ThreadPoolExecutor,
+            proton_vpn_api: ProtonVPNAPI
+    ):
+        super().__init__()
+        self._thread_pool = thread_pool_executor
+        self._api = proton_vpn_api
+        self._reload_session_source_id: int = None
+        self._refresh_time = 1
+
+    @property
+    def enabled(self):
+        """Whether the refresher has already been enabled or not."""
+        return self._reload_session_source_id is not None
+
+    def enable(self):
+        """Starts periodically refreshing the session."""
+        logger.info("Session refresher enabled.")
+
+        self._schedule_session_refresh(
+            delay_in_seconds=self._refresh_time
+        )
+
+        self._refresh_time = 3600
+
+    def disable(self):
+        """Stops periodically refreshing the session."""
+        if self._reload_session_source_id is not None:
+            GLib.source_remove(self._reload_session_source_id)
+            self._reload_session_source_id = None
+            logger.info("Session refresher disabled.")
+
+    def _refresh(self):
+        refresh = self._api.refresh_session()
+        if refresh is not None:
+            self._refresh_time = refresh
+        else:
+            logger.info("Session refreshed.")
+
+        self._schedule_session_refresh(
+            delay_in_seconds=self._refresh_time
+        )
+
+    def _schedule_session_refresh(self, delay_in_seconds: int):
+        """Schedules the next session refresh."""
+        self._reload_session_source_id = run_after_seconds(
+            self._refresh,
+            delay_seconds=delay_in_seconds
+        )
+        logger.info(
+            f"Next session refresh scheduled in "
+            f"{timedelta(seconds=delay_in_seconds)}"
+        )
+
diff -rupN original/proton/vpn/app/gtk/services/refresher/vpn_data_refresher.py proton/vpn/app/gtk/services/refresher/vpn_data_refresher.py
--- original/proton/vpn/app/gtk/services/refresher/vpn_data_refresher.py	2023-07-24 11:01:59.000000000 +0700
+++ proton/vpn/app/gtk/services/refresher/vpn_data_refresher.py	2023-07-24 08:35:51.129148832 +0700
@@ -28,6 +28,7 @@ from typing import Callable, Any, Dict
 from gi.repository import GLib, GObject
 
 from proton.vpn import logging
+from proton.vpn.app.gtk.services.refresher.session_refresher import SessionRefresher
 from proton.vpn.session.client_config import ClientConfig
 from proton.vpn.session.servers.logicals import ServerList
 from proton.vpn.core_api.api import ProtonVPNAPI
@@ -51,7 +52,8 @@ class VPNDataRefresher(GObject.Object):
         thread_pool_executor: ThreadPoolExecutor,
         proton_vpn_api: ProtonVPNAPI,
         client_config_refresher: ClientConfigRefresher = None,
-        server_list_refresher: ServerListRefresher = None
+        server_list_refresher: ServerListRefresher = None,
+        session_refresher: SessionRefresher = None
     ):
         super().__init__()
         self._thread_pool = thread_pool_executor
@@ -64,10 +66,15 @@ class VPNDataRefresher(GObject.Object):
             thread_pool_executor,
             proton_vpn_api
         )
+        self._session_refresher = session_refresher or SessionRefresher(
+            thread_pool_executor,
+            proton_vpn_api
+        )
         self._signal_refresher_map = {
             "new-client-config": self._client_config_refresher,
             "new-server-list": self._server_list_refresher,
-            "new-server-loads": self._server_list_refresher
+            "new-server-loads": self._server_list_refresher,
+            "new-session": self._session_refresher
         }
         self._signal_handler_ids: Dict[int, GObject.Object] = {}
 
@@ -138,6 +145,7 @@ class VPNDataRefresher(GObject.Object):
         """Stops retrieving data periodically from Proton's REST API."""
         self._client_config_refresher.disable()
         self._server_list_refresher.disable()
+        self._session_refresher.disable()
         logger.info(
             "VPN data refresher service disabled.",
             category="app", subcategory="vpn_data_refresher", event="disable"
@@ -151,6 +159,7 @@ class VPNDataRefresher(GObject.Object):
         )
         self._client_config_refresher.enable()
         self._server_list_refresher.enable()
+        self._session_refresher.enable()
 
     def _refresh_vpn_session_and_then_enable(self):
         logger.warning("Reloading VPN session...")
diff -rupN original/proton/vpn/app/gtk/widgets/headerbar/menu/menu.py proton/vpn/app/gtk/widgets/headerbar/menu/menu.py
--- original/proton/vpn/app/gtk/widgets/headerbar/menu/menu.py	2023-07-24 11:01:59.000000000 +0700
+++ proton/vpn/app/gtk/widgets/headerbar/menu/menu.py	2023-07-23 18:38:11.915762499 +0700
@@ -35,6 +35,8 @@ from proton.vpn.app.gtk.widgets.headerba
 
 from proton.session.exceptions import ProtonAPINotReachable
 from proton.vpn import logging
+from proton.vpn.connection import script
+from proton.vpn.connection.constants import WIREGUARD_FW_MARK, WIREGUARD_DEVICE_NAME
 
 logger = logging.getLogger(__name__)
 
@@ -65,6 +67,8 @@ class Menu(Gio.Menu):  # pylint: disable
         self.settings_action = Gio.SimpleAction.new("settings", None)
         self.release_notes_action = Gio.SimpleAction.new("release_notes", None)
         self.about_action = Gio.SimpleAction.new("about", None)
+        self.clear_nm_action = Gio.SimpleAction.new("clear_nm", None)
+        self.clear_ip_table_action = Gio.SimpleAction.new("clear_ip_table", None)
         self.logout_action = Gio.SimpleAction.new("logout", None)
         self.quit_action = Gio.SimpleAction.new("quit", None)
 
@@ -72,6 +76,8 @@ class Menu(Gio.Menu):  # pylint: disable
         self.append_item(Gio.MenuItem.new("Settings", "win.settings"))
         self.append_item(Gio.MenuItem.new("Release notes", "win.release_notes"))
         self.append_item(Gio.MenuItem.new("Report an issue", "win.report"))
+        self.append_item(Gio.MenuItem.new("Clear NetworkManager", "win.clear_nm"))
+        self.append_item(Gio.MenuItem.new("Clear IP table (root)", "win.clear_ip_table"))
         self.append_item(Gio.MenuItem.new("Logout", "win.logout"))
         self.append_item(Gio.MenuItem.new("Quit", "win.quit"))
 
@@ -107,6 +113,8 @@ class Menu(Gio.Menu):  # pylint: disable
         self._main_window.add_action(self.settings_action)
         self._main_window.add_action(self.release_notes_action)
         self._main_window.add_action(self.about_action)
+        self._main_window.add_action(self.clear_nm_action)
+        self._main_window.add_action(self.clear_ip_table_action)
         self._main_window.add_action(self.logout_action)
         self._main_window.add_action(self.quit_action)
 
@@ -123,6 +131,12 @@ class Menu(Gio.Menu):  # pylint: disable
         self.about_action.connect(
             "activate", self._on_about_clicked
         )
+        self.clear_nm_action.connect(
+            "activate", self._on_clear_nm_clicked
+        )
+        self.clear_ip_table_action.connect(
+            "activate", self._on_clear_ip_table_clicked
+        )
         self.logout_action.connect(
             "activate", self._on_logout_clicked
         )
@@ -155,6 +169,18 @@ class Menu(Gio.Menu):  # pylint: disable
         about_dialog.run()
         about_dialog.destroy()
 
+    def _on_clear_nm_clicked(self, *_):
+        logger.info("Clear NetworkManager button clicked", category="ui", subcategory="clear_nm", event="click")
+        self._loading_widget.show("Clearing NetworkManager...")
+        script.clear_nm()
+        self._loading_widget.hide()
+
+    def _on_clear_ip_table_clicked(self, *_):
+        logger.info("Clear IP table button clicked", category="ui", subcategory="clear_ip_table", event="click")
+        self._loading_widget.show("Clearing IP table...")
+        script.run_wg(False, interface=WIREGUARD_DEVICE_NAME, fw_mark=WIREGUARD_FW_MARK)
+        self._loading_widget.hide()
+
     def _on_logout_clicked(self, *_):
         logger.info("Logout button clicked", category="ui", subcategory="logout", event="click")
         self.logout_enabled = False
diff -rupN original/proton/vpn/app/gtk/widgets/headerbar/menu/settings/connection_settings.py proton/vpn/app/gtk/widgets/headerbar/menu/settings/connection_settings.py
--- original/proton/vpn/app/gtk/widgets/headerbar/menu/settings/connection_settings.py	2023-07-24 11:01:59.000000000 +0700
+++ proton/vpn/app/gtk/widgets/headerbar/menu/settings/connection_settings.py	2023-07-22 15:26:45.549458079 +0700
@@ -19,6 +19,7 @@ GNU General Public License for more deta
 You should have received a copy of the GNU General Public License
 along with ProtonVPN.  If not, see <https://www.gnu.org/licenses/>.
 """
+from concurrent.futures import Future
 
 from gi.repository import Gtk
 from proton.vpn.app.gtk.controller import Controller
@@ -26,6 +27,8 @@ from proton.vpn.app.gtk.widgets.main.not
 from proton.vpn.app.gtk.widgets.headerbar.menu.settings.common import (
     RECONNECT_MESSAGE, CategoryHeader, SettingRow, SettingName, SettingDescription
 )
+from proton.vpn.core_api.settings import KillSwitchMode
+from proton.vpn.killswitch.interface import KillSwitch
 
 
 class ConnectionSettings(Gtk.Box):
@@ -35,6 +38,8 @@ class ConnectionSettings(Gtk.Box):
     VPN_ACCELERATOR_LABEL = "VPN Accelerator"
     VPN_ACCELERATOR_DESCRIPTION = "Increase your connection speed by up to 400% "\
         "with performance enhancing technologies."
+    KILL_SWITCH_LABEL = "VPN Kill Switch"
+    KILL_SWITCH_DESCRIPTION = "Automatically block all internet traffic "
 
     def __init__(self, controller: Controller, notification_bar: NotificationBar):
         super().__init__(orientation=Gtk.Orientation.VERTICAL)
@@ -47,6 +52,8 @@ class ConnectionSettings(Gtk.Box):
         self.vpn_accelerator_row = None
         self.protocol_row = None
 
+        self.kill_switch_row = None
+
         self.get_style_context().add_class("setting-category")
 
     def build_ui(self):
@@ -55,6 +62,7 @@ class ConnectionSettings(Gtk.Box):
         self.pack_start(CategoryHeader(self.CATEGORY_NAME), False, False, 0)
         self.build_protocol()
         self.build_vpn_accelerator()
+        self.build_kill_switch()
 
     @property
     def protocol(self) -> str:
@@ -80,6 +88,18 @@ class ConnectionSettings(Gtk.Box):
         self._controller.get_settings().features.vpn_accelerator = newvalue
         self._controller.save_settings()
 
+    @property
+    def kill_switch(self) -> KillSwitchMode:
+        """Shortcut property that returns the current `kill_switch` setting"""
+        return self._controller.get_settings().features.kill_switch
+
+    @kill_switch.setter
+    def kill_switch(self, newvalue: KillSwitchMode):
+        """Shortcut property that sets the new `kill_switch` setting and
+        stores to disk."""
+        self._controller.get_settings().features.kill_switch = newvalue
+        self._controller.save_settings()
+
     def build_protocol(self):
         """Builds and adds the `protocol` setting to the widget."""
         def on_combobox_changed(combobox):
@@ -100,6 +120,7 @@ class ConnectionSettings(Gtk.Box):
         human_readeable_protocol = {
             "openvpn-tcp": "OpenVPN (TCP)",
             "openvpn-udp": "OpenVPN (UDP)",
+            "wireguard": "WireGuard"
         }
 
         for protocol in available_protocols:
@@ -142,3 +163,70 @@ class ConnectionSettings(Gtk.Box):
         vpn_accelerator_switch.set_state(self.vpn_accelerator)
         vpn_accelerator_switch.connect("state-set", on_switch_state)
         self.pack_start(self.vpn_accelerator_row, False, False, 0)
+
+    def build_kill_switch(self):
+        """Builds and adds the `kill_switch` setting to the widget."""
+
+        def on_combobox_change(combobox):
+            model = combobox.get_model()
+            treeiter = combobox.get_active_iter()
+            old_kill_switch = self.kill_switch
+            self.kill_switch = int(model[treeiter][1])
+            ks_instance: KillSwitch = KillSwitch.get()()
+
+            def _on_enable(_future: Future):
+                _future.result()
+
+            active = self._controller.is_connection_active
+            if self.kill_switch == KillSwitchMode.HARD:
+                future_ipv4 = ks_instance.enable()
+                future_ipv4.add_done_callback(_on_enable)
+
+                future_ipv6 = ks_instance.enable_ipv6_leak_protection()
+                future_ipv6.add_done_callback(_on_enable)
+
+                if active:
+                    self._notification_bar.show_info_message(
+                        f"{RECONNECT_MESSAGE}"
+                    )
+            elif old_kill_switch == KillSwitchMode.HARD:
+                if self.kill_switch == KillSwitchMode.DISABLED or (self.kill_switch == KillSwitchMode.SOFT and not active):
+                    future_ipv4 = ks_instance.disable()
+                    future_ipv4.add_done_callback(_on_enable)
+
+                    future_ipv6 = ks_instance.disable_ipv6_leak_protection()
+                    future_ipv6.add_done_callback(_on_enable)
+
+                    future_route = ks_instance.disable_route()
+                    future_route.add_done_callback(_on_enable)
+            else:
+                if active:
+                    self._notification_bar.show_info_message(
+                        f"{RECONNECT_MESSAGE}"
+                    )
+
+
+        ks_combobox = Gtk.ComboBoxText()
+        ks_combobox.set_hexpand(True)
+        ks_combobox.set_halign(Gtk.Align.END)
+
+        human_readable_switch = {
+            KillSwitchMode.DISABLED: "Disabled",
+            KillSwitchMode.SOFT: "Soft",
+            KillSwitchMode.HARD: "Hard"
+        }
+
+        for ks_mode in human_readable_switch:
+            ks_combobox.append(str(ks_mode), human_readable_switch[ks_mode])
+
+        ks_combobox.set_entry_text_column(1)
+        ks_combobox.set_active_id(str(self.kill_switch))
+        ks_combobox.connect("changed", on_combobox_change)
+
+        self.kill_switch_row = SettingRow(
+            SettingName(self.KILL_SWITCH_LABEL),
+            ks_combobox,
+            SettingDescription(self.KILL_SWITCH_DESCRIPTION)
+        )
+
+        self.pack_start(self.kill_switch_row, False, False, 0)
\ No newline at end of file
diff -rupN original/proton/vpn/backend/linux/networkmanager/core/networkmanager.py proton/vpn/backend/linux/networkmanager/core/networkmanager.py
--- original/proton/vpn/backend/linux/networkmanager/core/networkmanager.py	2023-07-24 11:01:59.000000000 +0700
+++ proton/vpn/backend/linux/networkmanager/core/networkmanager.py	2023-07-23 16:43:37.615433338 +0700
@@ -69,7 +69,6 @@ class LinuxNetworkManager(VPNConnection)
         """
         Starts a VPN connection using NetworkManager.
         """
-
         def start_if_server_reachable(server_reachable: bool):
             if server_reachable:
                 logger.info("VPN server REACHABLE.")
@@ -126,10 +125,16 @@ class LinuxNetworkManager(VPNConnection)
                 self.remove_connection()
                 return
 
-            vpn_connection.connect(
-                "vpn-state-changed",
-                self._on_vpn_state_changed
-            )
+            try:
+                vpn_connection.connect(
+                    "vpn-state-changed",
+                    self._on_vpn_state_changed
+                )
+            except TypeError:
+                vpn_connection.connect(
+                    "state-changed",
+                    self._on_active_state_changed
+                )
 
         # start_connection_future is done as soon as the VPN connection
         # is activated, but before it's established. As soon as the
@@ -153,6 +158,61 @@ class LinuxNetworkManager(VPNConnection)
         super().remove_persistence()
         self.remove_connection()
 
+
+    def _on_active_state_changed(self, active_connection: NM.ActiveConnection, state: int, reason: int):
+        try:
+            state = NM.ActiveConnectionState(state)
+        except ValueError:
+            logger.warning("Unexpected VPN connection state: %s", state)
+            state = NM.ActiveConnectionState.UNKNOWN
+
+        try:
+            reason = NM.ActiveConnectionStateReason(reason)
+        except ValueError:
+            logger.warning("Unexpected VPN connection state reason: %s", reason)
+            reason = NM.ActiveConnectionState.UNKNOWN
+
+        logger.info(
+            f"VPN connection state changed: state=%s (), reason=%s",
+            state.value_name, reason.value_name
+        )
+
+        if state is NM.ActiveConnectionState.ACTIVATED:
+            self._notify_subscribers(events.Connected(EventContext(connection=self)))
+        elif state is NM.ActiveConnectionState.UNKNOWN:
+            if reason in [
+                NM.ActiveConnectionStateReason.CONNECT_TIMEOUT,
+                NM.ActiveConnectionStateReason.SERVICE_START_TIMEOUT
+            ]:
+                self._notify_subscribers(
+                    events.Timeout(EventContext(connection=self, error=reason))
+                )
+            else:
+                self._notify_subscribers(
+                    events.UnexpectedError(EventContext(connection=self, error=reason))
+                )
+        elif state == NM.ActiveConnectionState.DEACTIVATED:
+            if reason in [NM.ActiveConnectionStateReason.DEVICE_DISCONNECTED]:
+                self._notify_subscribers(
+                    events.Disconnected(EventContext(connection=self, error=reason))
+                )
+            elif reason in [
+                NM.ActiveConnectionStateReason.CONNECT_TIMEOUT,
+                NM.ActiveConnectionStateReason.SERVICE_START_TIMEOUT,
+                NM.ActiveConnectionStateReason.SERVICE_START_FAILED,
+                NM.ActiveConnectionStateReason.LOGIN_FAILED,
+                NM.ActiveConnectionStateReason.UNKNOWN,
+                NM.ActiveConnectionStateReason.NONE,
+                NM.ActiveConnectionStateReason.DEPENDENCY_FAILED,
+                NM.ActiveConnectionStateReason.IP_CONFIG_INVALID,
+                NM.ActiveConnectionStateReason.CONNECT_TIMEOUT,
+            ]:
+                self._notify_subscribers(
+                    events.UnexpectedError(EventContext(connection=self, error=reason))
+                )
+        else:
+            logger.debug("Ignoring VPN state change: %s", state.value_name)
+
     # pylint: disable=unused-argument
     def _on_vpn_state_changed(
             self, vpn_connection: NM.VpnConnection, state: int, reason: int
diff -rupN original/proton/vpn/backend/linux/networkmanager/protocol/wireguard/__init__.py proton/vpn/backend/linux/networkmanager/protocol/wireguard/__init__.py
--- original/proton/vpn/backend/linux/networkmanager/protocol/wireguard/__init__.py	1970-01-01 07:00:00.000000000 +0700
+++ proton/vpn/backend/linux/networkmanager/protocol/wireguard/__init__.py	2023-07-22 15:29:16.728259585 +0700
@@ -0,0 +1,3 @@
+from proton.vpn.backend.linux.networkmanager.protocol.wireguard.wireguard import WireGuardUDP as WireGuard
+
+__all__ = ["WireGuard"]
\ No newline at end of file
diff -rupN original/proton/vpn/backend/linux/networkmanager/protocol/wireguard/wireguard.py proton/vpn/backend/linux/networkmanager/protocol/wireguard/wireguard.py
--- original/proton/vpn/backend/linux/networkmanager/protocol/wireguard/wireguard.py	1970-01-01 07:00:00.000000000 +0700
+++ proton/vpn/backend/linux/networkmanager/protocol/wireguard/wireguard.py	2023-07-23 16:45:49.557699684 +0700
@@ -0,0 +1,116 @@
+import time
+import uuid
+from concurrent.futures import Future
+
+import gi
+
+from proton.vpn.connection.constants import WIREGUARD_DEVICE_NAME, WIREGUARD_FW_MARK
+
+gi.require_version("NM", "1.0")  # noqa: required before importing NM module
+# pylint: disable=wrong-import-position
+from gi.repository import NM, GLib
+
+from proton.vpn.backend.linux.networkmanager.core import LinuxNetworkManager
+from proton.vpn.connection.vpnconfiguration import VPNConfiguration
+from ipaddress import ip_network
+
+class WireGuard(LinuxNetworkManager):
+    """Base class for the backends implementing the WireGuard protocols."""
+    virtual_device_name = WIREGUARD_DEVICE_NAME
+    connection = None
+
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
+        self.__connection_settings = None
+
+    def _calculate_allowed_ips(self) -> list:
+        """Calculates the allowed IPs for the WireGuard connection."""
+        server_ips = self._vpnserver.server_ip
+        subnet = ip_network('0.0.0.0/0').address_exclude(ip_network(server_ips))
+        return [str(ip) for ip in subnet]
+
+    def _configure_connection(self, vpnconfig):
+        """Configure imported vpn connection.
+
+            :param vpnconfig: vpn configuration object.
+            :type vpnconfig: VPNConfiguration
+
+        It also uses vpnserver, vpncredentials and settings for the following reasons:
+            - vpnserver is used to fetch domain, servername (optional)
+            - vpncredentials is used to fetch username/password for non-certificate
+              based connections
+            - settings is used to fetch dns settings
+        """
+        self.connection = NM.SimpleConnection.new()
+
+        s_con = NM.SettingConnection.new()
+
+        # Connection setting
+        s_con.set_property(NM.SETTING_CONNECTION_TYPE, 'wireguard')
+        s_con.set_property(NM.SETTING_CONNECTION_ID, self._get_servername())
+        s_con.set_property(NM.SETTING_CONNECTION_UUID, str(uuid.uuid4()))
+        s_con.set_property(NM.SETTING_CONNECTION_INTERFACE_NAME, self.virtual_device_name)
+        s_con.set_property(NM.SETTING_CONNECTION_AUTOCONNECT, False)
+
+        # IPv4
+        s_ip4 = NM.SettingIP4Config.new()
+        s_ip4.set_property(NM.SETTING_IP_CONFIG_METHOD, 'manual')
+        s_ip4.add_address(
+            NM.IPAddress.new(GLib.SYSDEF_AF_INET, '10.2.0.2', 32)
+        )
+        s_ip4.add_dns('10.2.0.1')
+        s_ip4.props.dns_priority = -1500
+        s_ip4.props.route_metric = 50
+
+        # WireGuard
+        s_wg = NM.SettingWireGuard.new()
+        s_wg.set_property(NM.SETTING_WIREGUARD_PRIVATE_KEY, self._vpncredentials.pubkey_credentials.wg_private_key)
+        s_wg.set_property(NM.SETTING_WIREGUARD_PEER_ROUTES, True)
+        s_wg.set_property(NM.SETTING_WIREGUARD_MTU, 0)
+        s_wg.set_property(NM.SETTING_WIREGUARD_IP4_AUTO_DEFAULT_ROUTE, True)
+        s_wg.set_property(NM.SETTING_WIREGUARD_FWMARK, WIREGUARD_FW_MARK)
+
+        # Wireguard Peer
+
+        peer = NM.WireGuardPeer.new()
+        peer.set_public_key(self._vpnserver.x25519pk, False)
+        peer.set_endpoint(self._vpnserver.server_ip + ':' + str(self._vpnserver.udp_ports[0]), False)
+
+        # for ip in self._calculate_allowed_ips():
+        #     peer.append_allowed_ip(ip, False)
+
+        peer.append_allowed_ip('0.0.0.0/0', False)
+        peer.append_allowed_ip('::/0', False)
+
+        s_wg.append_peer(peer)
+
+        # Add settings to connection
+        self.connection.add_setting(s_con)
+        self.connection.add_setting(s_ip4)
+        self.connection.add_setting(s_wg)
+
+        self.__connection_settings = self.connection.get_setting_connection()
+
+        self._unique_id = self.__connection_settings.get_uuid()
+
+    def _setup(self) -> Future:
+        vpnconfig = VPNConfiguration.from_factory(self.protocol)
+        vpnconfig = vpnconfig(self._vpnserver, self._vpncredentials, self._settings)
+        vpnconfig.use_certificate = True
+
+        self._configure_connection(vpnconfig)
+
+        return self.nm_client.add_connection_async(self.connection)
+
+
+class WireGuardUDP(WireGuard):
+    """Creates a WireGuard UDP connection."""
+    protocol = "wireguard"
+
+    @classmethod
+    def _get_priority(cls):
+        return 1
+
+    @classmethod
+    def _validate(cls):
+        return True
diff -rupN original/proton/vpn/connection/constants.py proton/vpn/connection/constants.py
--- original/proton/vpn/connection/constants.py	2023-07-24 11:01:59.000000000 +0700
+++ proton/vpn/connection/constants.py	2023-07-23 18:32:35.115476705 +0700
@@ -55,6 +55,28 @@ A1gTTlpi7A==
 -----END CERTIFICATE-----
 """
 
+# 2048 bit OpenVPN static key
+TLS_AUTH = """
+-----BEGIN OpenVPN Static key V1-----
+6acef03f62675b4b1bbd03e53b187727
+423cea742242106cb2916a8a4c829756
+3d22c7e5cef430b1103c6f66eb1fc5b3
+75a672f158e2e2e936c3faa48b035a6d
+e17beaac23b5f03b10b868d53d03521d
+8ba115059da777a60cbfd7b2c9c57472
+78a15b8f6e68a3ef7fd583ec9f398c8b
+d4735dab40cbd1e3c62a822e97489186
+c30a0b48c7c38ea32ceb056d3fa5a710
+e10ccc7a0ddb363b08c3d2777a3395e1
+0c0b6080f56309192ab5aacd4b45f55d
+a61fc77af39bd81a19218a79762c3386
+2df55785075f37d8c71dc8a42097ee43
+344739a0dd48d03025b0450cf1fb5e8c
+aeb893d9a96d1f15519bb3c4dcb40ee3
+16672ea16c012664f8a9f11255518deb
+-----END OpenVPN Static key V1-----
+"""
+
 OPENVPN_V2_TEMPLATE = """
 # ==============================================================================
 # Copyright (c) 2016-2020 Proton Technologies AG (Switzerland)
@@ -116,32 +138,11 @@ auth-user-pass
 pull
 fast-io
 
-<ca>
-{{ca_certificate}}
-</ca>
+ca {{ca_certificate}}
 
 key-direction 1
-<tls-auth>
-# 2048 bit OpenVPN static key
------BEGIN OpenVPN Static key V1-----
-6acef03f62675b4b1bbd03e53b187727
-423cea742242106cb2916a8a4c829756
-3d22c7e5cef430b1103c6f66eb1fc5b3
-75a672f158e2e2e936c3faa48b035a6d
-e17beaac23b5f03b10b868d53d03521d
-8ba115059da777a60cbfd7b2c9c57472
-78a15b8f6e68a3ef7fd583ec9f398c8b
-d4735dab40cbd1e3c62a822e97489186
-c30a0b48c7c38ea32ceb056d3fa5a710
-e10ccc7a0ddb363b08c3d2777a3395e1
-0c0b6080f56309192ab5aacd4b45f55d
-a61fc77af39bd81a19218a79762c3386
-2df55785075f37d8c71dc8a42097ee43
-344739a0dd48d03025b0450cf1fb5e8c
-aeb893d9a96d1f15519bb3c4dcb40ee3
-16672ea16c012664f8a9f11255518deb
------END OpenVPN Static key V1-----
-</tls-auth>
+tls-auth {{tls_auth}}
+
 
 {%- if certificate_based %}
 <cert>
@@ -164,3 +165,15 @@ PublicKey = {{ wg_server_pk }}
 Endpoint = {{ wg_ip }}:{{ wg_port }}
 AllowedIPs = 0.0.0.0/0
 """
+
+HUMAN_READABLE_ID = "pvpn-killswitch"
+INTERFACE_NAME = "pvpnksintrf0"
+
+IPV6_HUMAN_READABLE_ID = "pvpn-killswitch-ipv6"
+IPV6_INTERFACE_NAME = "ipv6leakintrf0"
+
+ROUTE_HUMAN_READABLE_ID = "pvpn-killswitch-route"
+ROUTE_INTERFACE_NAME = "pvpnksroute0"
+
+WIREGUARD_FW_MARK = 1234
+WIREGUARD_DEVICE_NAME = "proton0"
diff -rupN original/proton/vpn/connection/interfaces.py proton/vpn/connection/interfaces.py
--- original/proton/vpn/connection/interfaces.py	2023-07-24 11:01:59.000000000 +0700
+++ proton/vpn/connection/interfaces.py	2023-07-20 19:29:53.148907931 +0700
@@ -156,6 +156,14 @@ class Features:
         return None
 
     @property
+    def kill_switch(self):
+        """
+        :return: kill switch state value
+        :rtype: KillSwitchMode
+        """
+        return None
+
+    @property
     def port_forwarding(self):
         """
         :return: port forwarding state value
diff -rupN original/proton/vpn/connection/script.py proton/vpn/connection/script.py
--- original/proton/vpn/connection/script.py	1970-01-01 07:00:00.000000000 +0700
+++ proton/vpn/connection/script.py	2023-07-23 21:58:11.328465236 +0700
@@ -0,0 +1,63 @@
+import logging
+import subprocess
+
+from proton.vpn.connection.constants import HUMAN_READABLE_ID, ROUTE_HUMAN_READABLE_ID, IPV6_HUMAN_READABLE_ID
+
+logger = logging.getLogger(__name__)
+
+FW_MARK_SCRIPT = """
+enable() {
+    iptables -I OUTPUT ! -o "$1" -m mark ! --mark $2 -m addrtype ! --dst-type LOCAL -j REJECT
+    ip6tables -I OUTPUT ! -o "$1" -m mark ! --mark $2 -m addrtype ! --dst-type LOCAL -j REJECT
+}
+
+disable() {
+    iptables -D OUTPUT ! -o "$1" -m mark ! --mark $2 -m addrtype ! --dst-type LOCAL -j REJECT
+    ip6tables -D OUTPUT ! -o "$1" -m mark ! --mark $2 -m addrtype ! --dst-type LOCAL -j REJECT
+}
+
+if [ "$0" = "enable" ]; then
+    enable "$1" $2
+    exit 1
+elif [ "$0" = "disable" ]; then
+    disable "$1" $2
+    exit 1
+fi
+
+echo "Usage: $0 [enable|disable] <interface> <fw_mark>"
+echo "What you run: $0 $1 $2"
+
+"""
+
+
+def run_wg(enable: bool, interface: str = 'proton0', fw_mark: int = 1000) -> (str | None, str | None):
+    enable_str = "enable" if enable else "disable"
+    bash_process = subprocess.run(['pkexec', 'bash', '-c', FW_MARK_SCRIPT, enable_str, interface, str(fw_mark)],
+                                  capture_output=True)
+
+    stdout = bash_process.stdout.decode()
+    stderr = bash_process.stderr.decode()
+
+    if enable:
+        logger.info("Enabling general killswitch (wireguard)...")
+    else:
+        logger.info("Disabling general killswitch (wireguard)...")
+
+    if stdout != "":
+        logger.info(stdout)
+
+    if stderr != "":
+        if "does a matching rule exist in that chain?" in stderr:
+            logger.info("Nothing bad happened, it just means that the rule was already deleted!")
+            stderr = None
+        else:
+            logger.error(stderr)
+
+    return stdout, stderr
+
+
+def clear_nm():
+    general_ks = HUMAN_READABLE_ID
+    ipv6_ks = IPV6_HUMAN_READABLE_ID
+    route_ks = ROUTE_HUMAN_READABLE_ID
+    subprocess.run(['nmcli', 'connection', 'delete', general_ks, ipv6_ks, route_ks])
diff -rupN original/proton/vpn/connection/states.py proton/vpn/connection/states.py
--- original/proton/vpn/connection/states.py	2023-07-24 11:01:59.000000000 +0700
+++ proton/vpn/connection/states.py	2023-07-24 10:58:19.962486684 +0700
@@ -21,21 +21,23 @@ along with ProtonVPN.  If not, see <http
 """
 from __future__ import annotations
 
+import time
 from abc import ABC, abstractmethod
 from dataclasses import dataclass
 from typing import TYPE_CHECKING, Optional
 from concurrent.futures import Future
 
 from proton.vpn import logging
-from proton.vpn.connection import events
+from proton.vpn.connection import events, script
+from proton.vpn.connection.constants import WIREGUARD_DEVICE_NAME, WIREGUARD_FW_MARK
 from proton.vpn.connection.enum import ConnectionStateEnum
 from proton.vpn.connection.events import EventContext
 from proton.vpn.connection.exceptions import ConcurrentConnectionsError
+from proton.vpn.core_api.settings import KillSwitchMode
 
 if TYPE_CHECKING:
     from proton.vpn.connection.vpnconnection import VPNConnection
 
-
 # pylint: disable=too-few-public-methods
 
 
@@ -154,18 +156,47 @@ class Disconnected(State):
             return None
 
         if self.context.reconnection:
-            # When a reconnection is expected, an Up event is returned to start a new connection.
-            # straight away.
-            # IMPORTANT: in this case, the kill switch is **not** disabled.
-            return events.Up(EventContext(connection=self.context.reconnection))
+            if self.context.reconnection == self.context.connection:
+                # When a reconnection is expected, an Up event is returned to start a new connection.
+                # straight away.
+                # IMPORTANT: in this case, the kill switch is **not** disabled.
+                return events.Up(EventContext(connection=self.context.reconnection))
+
+        protocol = self.context.connection.protocol
+        ks_mode = self.context.connection.settings.features.kill_switch
 
-        def _on_ipv6_leak_protection_disabled(_future: Future):
+        def _on_call_back(_future: Future):
             _future.result()
 
         # When the state machine is in disconnected state, a VPN connection
         # may have not been created yet.
-        future = self.context.connection.disable_ipv6_leak_protection()
-        future.add_done_callback(_on_ipv6_leak_protection_disabled)
+
+        if ks_mode < KillSwitchMode.HARD:
+
+            if not self.context.reconnection:
+                future_ipv6 = self.context.connection.disable_ipv6_leak_protection()
+                future_ipv6.add_done_callback(_on_call_back)
+
+            if protocol != "wireguard":
+                future_leak = self.context.connection.disable_leak_protection()
+                future_leak.add_done_callback(_on_call_back)
+
+        if protocol == "wireguard" and ks_mode > KillSwitchMode.DISABLED:
+
+            if ks_mode == KillSwitchMode.HARD:
+                self.context.connection.enable_leak_protection().result()
+
+            process = script.run_wg(False, WIREGUARD_DEVICE_NAME, WIREGUARD_FW_MARK)
+
+            if process[1] != "":
+                logger.error(
+                    f"Error while disabling kill switch: {process[1]}",
+                    category="CONN", event="ERROR"
+                )
+
+        if self.context.reconnection:
+            return events.Up(EventContext(connection=self.context.reconnection))
+
         self.context.connection.remove_persistence()
         return None
 
@@ -176,6 +207,9 @@ class Connecting(State):
     """
     type = ConnectionStateEnum.CONNECTING
 
+    def __init__(self, context: StateContext = None):
+        super().__init__(context)
+
     def _on_event(self, event: events.Event):
         if isinstance(event, events.Connected):
             return Connected(StateContext(event=event, connection=event.context.connection))
@@ -206,12 +240,48 @@ class Connecting(State):
         return self
 
     def run_tasks(self):
-        def _on_ipv6_leak_protection_enabled(_future: Future):
+
+        if not self.context.connection:
+            return None
+
+        ks_mode: KillSwitchMode = self.context.connection.settings.features.kill_switch
+
+        def _on_disabled_task(_future: Future):
             _future.result()
             self.context.connection.start()
 
-        future = self.context.connection.enable_ipv6_leak_protection()
-        future.add_done_callback(_on_ipv6_leak_protection_enabled)
+        def _on_soft_task(_future: Future):
+
+            def _start_connection(_future: Future):
+                _future.result()
+                self.context.connection.start()
+
+            _future.result()
+            self.context.connection.enable_route().add_done_callback(_start_connection)
+
+        def _on_hard_task(_future: Future):
+
+            def _pre_connection(_future: Future):
+                _future.result()
+                self.context.connection.disable_leak_protection().add_done_callback(_start_connection)
+
+            def _start_connection(_future: Future):
+                _future.result()
+                time.sleep(3)  # Prevent timeout, as the change may take some time
+                self.context.connection.start()
+
+            _future.result()
+            self.context.connection.enable_route().add_done_callback(_pre_connection)
+
+        future_ipv6 = self.context.connection.enable_ipv6_leak_protection()
+
+        match ks_mode:
+            case KillSwitchMode.DISABLED:
+                future_ipv6.add_done_callback(_on_disabled_task)
+            case KillSwitchMode.SOFT:
+                future_ipv6.add_done_callback(_on_soft_task)
+            case KillSwitchMode.HARD:
+                future_ipv6.add_done_callback(_on_hard_task)
 
 
 class Connected(State):
@@ -248,6 +318,62 @@ class Connected(State):
         return self
 
     def run_tasks(self):
+        ks_mode = self.context.connection.settings.features.kill_switch
+
+        def _on_hard_task():
+
+            def _on_connected(_future: Future):
+                _future.result()
+                self.context.connection.disable_route().add_done_callback(_on_done)
+
+            def _on_done(_future: Future):
+                _future.result()
+
+            protocol = self.context.connection.protocol
+            if protocol == "wireguard":
+                process = script.run_wg(True, WIREGUARD_DEVICE_NAME, WIREGUARD_FW_MARK)
+                if process[1] != "":
+                    logger.error(
+                        f"Error while enabling kill switch: {process[1]}",
+                        category="CONN", event="ERROR"
+                    )
+                    self.context.connection.stop()
+                    return events.Disconnected(EventContext(connection=self.context.connection))
+                self.context.connection.disable_route().add_done_callback(_on_done)
+            else:
+                self.context.connection.enable_leak_protection().add_done_callback(_on_connected)
+
+        def _on_soft_task():
+
+            def _on_connected(_future: Future):
+                _future.result()
+                self.context.connection.disable_route().add_done_callback(_on_done)
+
+            def _on_done(_future: Future):
+                _future.result()
+
+            protocol = self.context.connection.protocol
+            if protocol == "wireguard":
+                process = script.run_wg(True, WIREGUARD_DEVICE_NAME, WIREGUARD_FW_MARK)
+                if process[1] != "":
+                    logger.error(
+                        f"Error while enabling kill switch: {process[1]}",
+                        category="CONN", event="ERROR"
+                    )
+                    self.context.connection.stop()
+                    return events.Disconnected(EventContext(connection=self.context.connection))
+                self.context.connection.disable_route().add_done_callback(_on_done)
+            else:
+                self.context.connection.enable_leak_protection().add_done_callback(_on_connected)
+
+        match ks_mode:
+            case KillSwitchMode.DISABLED:
+                pass
+            case KillSwitchMode.SOFT:
+                _on_soft_task()
+            case KillSwitchMode.HARD:
+                _on_hard_task()
+
         self.context.connection.add_persistence()
 
 
diff -rupN original/proton/vpn/connection/vpnconfiguration.py proton/vpn/connection/vpnconfiguration.py
--- original/proton/vpn/connection/vpnconfiguration.py	2023-07-24 11:01:59.000000000 +0700
+++ proton/vpn/connection/vpnconfiguration.py	2023-07-24 10:58:19.928486571 +0700
@@ -21,6 +21,7 @@ You should have received a copy of the G
 along with ProtonVPN.  If not, see <https://www.gnu.org/licenses/>.
 """
 import ipaddress
+import json
 import tempfile
 import os
 
@@ -28,8 +29,9 @@ from jinja2 import Environment, BaseLoad
 from proton.utils.environment import ExecutionEnvironment
 
 from proton.vpn.connection.constants import \
-    CA_CERT, OPENVPN_V2_TEMPLATE, WIREGUARD_TEMPLATE
+    TLS_AUTH, CA_CERT, OPENVPN_V2_TEMPLATE, WIREGUARD_TEMPLATE
 from proton.vpn.connection.interfaces import Settings
+from proton.vpn.core_api import certificate
 
 
 class DefaultSettings(Settings):
@@ -132,12 +134,13 @@ class OVPNConfig(VPNConfiguration):
             string: configuration file
         """
         ports = self._vpnserver.tcp_ports if "tcp" == self._protocol else self._vpnserver.udp_ports
-
+        certificate.check()
         j2_values = {
             "openvpn_protocol": self._protocol,
             "serverlist": [self._vpnserver.server_ip],
             "openvpn_ports": ports,
-            "ca_certificate": CA_CERT,
+            "ca_certificate": certificate.CA_CERT,
+            "tls_auth": certificate.TLS_AUTH,
             "certificate_based": self.use_certificate,
             "custom_dns": len(self.settings.dns_custom_ips) > 0,
         }
diff -rupN original/proton/vpn/connection/vpnconnection.py proton/vpn/connection/vpnconnection.py
--- original/proton/vpn/connection/vpnconnection.py	2023-07-24 11:01:59.000000000 +0700
+++ proton/vpn/connection/vpnconnection.py	2023-07-20 14:51:25.358409503 +0700
@@ -304,6 +304,42 @@ class VPNConnection(ABC):
         """
         self._connection_persistence.remove()
 
+    def enable_leak_protection(self) -> Future:
+        """
+        Prevents IP leaks.
+
+        This method should be called before establishing VPN connections,
+        so that no traffic leaks through the physical interface while connected
+        to the VPN.
+        """
+        return self._killswitch.enable()
+
+    def disable_leak_protection(self) -> Future:
+        """
+        Stops preventing IP leaks.
+
+        This method should be called after the user willingly ends a VPN connection.
+        """
+        return self._killswitch.disable()
+
+    def enable_route(self) -> Future:
+        """
+        Prevents IP leaks.
+
+        This method should be called before establishing VPN connections,
+        so that no traffic leaks through the physical interface while connected
+        to the VPN.
+        """
+        return self._killswitch.enable_route(self._vpnserver)
+
+    def disable_route(self) -> Future:
+        """
+        Stops preventing IP leaks.
+
+        This method should be called after the user willingly ends a VPN connection.
+        """
+        return self._killswitch.disable_route()
+
     def enable_ipv6_leak_protection(self) -> Future:
         """
         Prevents IPv6 leaks.
diff -rupN original/proton/vpn/core_api/api.py proton/vpn/core_api/api.py
--- original/proton/vpn/core_api/api.py	2023-07-24 11:01:59.000000000 +0700
+++ proton/vpn/core_api/api.py	2023-07-24 09:55:53.051106891 +0700
@@ -19,6 +19,8 @@ GNU General Public License for more deta
 You should have received a copy of the GNU General Public License
 along with ProtonVPN.  If not, see <https://www.gnu.org/licenses/>.
 """
+import math
+
 from proton.vpn.core_api.connection import VPNConnectorWrapper
 from proton.vpn.core_api.settings import Settings, SettingsPersistence
 from proton.vpn.core_api.session import SessionHolder, ClientTypeMetadata
@@ -134,6 +136,21 @@ class ProtonVPNAPI:
         """
         return self._session_holder.submit_bug_report(bug_report)
 
+    def refresh_session(self) -> None | int:
+        """
+        Refreshes the session.
+        :returns: The new session expiration timestamp or None if the session
+        """
+        time_remain = (self._session_holder.session.vpn_account.vpn_credentials
+                       .pubkey_credentials.certificate_validity_remaining)
+
+        if time_remain > 3600:
+            return int(time_remain) - 3600
+
+        self._session_holder.session.refresh()
+
+        self._session_holder.session.fetch_session_data()
+
     def logout(self):
         """
         Logs the current user out.
diff -rupN original/proton/vpn/core_api/certificate.py proton/vpn/core_api/certificate.py
--- original/proton/vpn/core_api/certificate.py	1970-01-01 07:00:00.000000000 +0700
+++ proton/vpn/core_api/certificate.py	2023-07-20 10:22:48.351370957 +0700
@@ -0,0 +1,38 @@
+import os.path
+
+from proton.utils.environment import VPNExecutionEnvironment
+from proton.vpn.connection import constants
+
+CA_CERT = os.path.join(
+    VPNExecutionEnvironment().path_config,
+    "ProtonVPN-ca.pem"
+)
+
+TLS_AUTH = os.path.join(
+    VPNExecutionEnvironment().path_config,
+    "ProtonVPN-tls-auth.pem"
+)
+
+
+# This is the function that is called to check if the certificate files exist and correct.
+def check():
+    if os.path.isfile(CA_CERT) and os.path.isfile(TLS_AUTH):
+        with open(CA_CERT, "r") as f:
+            if f.read() != constants.CA_CERT:
+                write()
+                return False
+        with open(TLS_AUTH, "r") as f:
+            if f.read() != constants.TLS_AUTH:
+                write()
+                return False
+        return True
+    else:
+        write()
+        return False
+
+
+def write():
+    with open(CA_CERT, "w") as f:
+        f.write(constants.CA_CERT)
+    with open(TLS_AUTH, "w") as f:
+        f.write(constants.TLS_AUTH)
diff -rupN original/proton/vpn/core_api/session.py proton/vpn/core_api/session.py
--- original/proton/vpn/core_api/session.py	2023-07-24 11:01:59.000000000 +0700
+++ proton/vpn/core_api/session.py	2023-07-24 10:58:19.946486631 +0700
@@ -67,6 +67,7 @@ class SessionHolder:
             account_name=username,
             override_class=VPNSession
         )
+
         return self._session
 
     @property
@@ -76,7 +77,6 @@ class SessionHolder:
             self._session = self._proton_sso.get_default_session(
                 override_class=VPNSession
             )
-
         return self._session
 
     def submit_bug_report(self, bug_report: BugReportForm):
diff -rupN original/proton/vpn/core_api/settings.py proton/vpn/core_api/settings.py
--- original/proton/vpn/core_api/settings.py	2023-07-24 11:01:59.000000000 +0700
+++ proton/vpn/core_api/settings.py	2023-07-22 13:41:26.669099394 +0700
@@ -36,6 +36,12 @@ class NetShield(IntEnum):  # pylint: dis
     BLOCK_ADS_AND_TRACKING = 2
 
 
+class KillSwitchMode(IntEnum):
+    DISABLED = 0
+    SOFT = 1
+    HARD = 2
+
+
 SETTINGS = os.path.join(
     VPNExecutionEnvironment().path_config,
     "settings.json"
@@ -51,6 +57,7 @@ class Features:
     netshield: NetShield
     random_nat: bool
     vpn_accelerator: bool
+    kill_switch: KillSwitchMode
     port_forwarding: bool
 
     @staticmethod
@@ -62,6 +69,7 @@ class Features:
             netshield=data.get("netshield", default.netshield),
             random_nat=data.get("random_nat", default.random_nat),
             vpn_accelerator=data.get("vpn_accelerator", default.vpn_accelerator),
+            kill_switch=data.get("kill_switch", default.kill_switch),
             port_forwarding=data.get("port_forwarding", default.port_forwarding),
         )
 
@@ -76,6 +84,7 @@ class Features:
             ),
             random_nat=True,
             vpn_accelerator=True,
+            kill_switch=KillSwitchMode.DISABLED,
             port_forwarding=False
         )
 
diff -rupN original/proton/vpn/killswitch/backend/linux/networkmanager/killswitch_connection_handler.py proton/vpn/killswitch/backend/linux/networkmanager/killswitch_connection_handler.py
--- original/proton/vpn/killswitch/backend/linux/networkmanager/killswitch_connection_handler.py	2023-07-24 11:01:59.000000000 +0700
+++ proton/vpn/killswitch/backend/linux/networkmanager/killswitch_connection_handler.py	2023-07-24 08:35:51.133148844 +0700
@@ -19,22 +19,18 @@ GNU General Public License for more deta
 You should have received a copy of the GNU General Public License
 along with ProtonVPN.  If not, see <https://www.gnu.org/licenses/>.
 """
+from ipaddress import ip_network
 from concurrent.futures import Future
+
 from proton.vpn import logging
+from proton.vpn.connection.constants import HUMAN_READABLE_ID, INTERFACE_NAME, ROUTE_HUMAN_READABLE_ID, \
+    ROUTE_INTERFACE_NAME, IPV6_HUMAN_READABLE_ID, IPV6_INTERFACE_NAME
 from proton.vpn.killswitch.backend.linux.networkmanager.nmclient import NMClient
 from proton.vpn.killswitch.backend.linux.networkmanager.killswitch_connection import (
-    KillSwitchConnection, KillSwitchGeneralConfig, KillSwitchIPConfig
+    KillSwitchConnection, KillSwitchGeneralConfig, KillSwitchIPConfig, ip_route
 )
 
 logger = logging.getLogger(__name__)
-
-HUMAN_READABLE_ID = "pvpn-killswitch"
-INTERFACE_NAME = "pvpnksintrf0"
-
-IPV6_HUMAN_READABLE_ID = "pvpn-killswitch-ipv6"
-IPV6_INTERFACE_NAME = "ipv6leakintrf0"
-
-
 class KillSwitchConnectionHandler:
     """Kill switch connection management."""
 
@@ -57,21 +53,104 @@ class KillSwitchConnectionHandler:
     @property
     def is_killswitch_connection_active(self) -> bool:
         """Returns if general kill switch is active or not."""
-        return False
+        return bool(self.nm_client.get_active_connection(HUMAN_READABLE_ID))
 
-    def add(self, server_ip: str):
+    def add(self) -> Future:
         """Adds general kill switch to NetworkManager"""
-        raise NotImplementedError
+        general_config = KillSwitchGeneralConfig(
+            human_readable_id=HUMAN_READABLE_ID,
+            interface_name=INTERFACE_NAME
+        )
+        ipv4_config = KillSwitchIPConfig(
+            addresses=["10.18.0.1/16"],
+            dns=["0.0.0.0"],
+            dns_priority=-1400,
+            gateway="10.18.0.1",
+            ignore_auto_dns=True,
+            route_metric=97
+        )
 
-    def remove(self):
+        ipv6_config = KillSwitchIPConfig(
+            addresses=["fdeb:446c:912d:08da::/64"],
+            dns=["::1"],
+            dns_priority=-1400,
+            gateway="fdeb:446c:912d:08da::1",
+            ignore_auto_dns=True,
+            route_metric=97
+        )
+
+        kill_switch = KillSwitchConnection(
+            general_config,
+            ipv4_settings=ipv4_config,
+            ipv6_settings=ipv6_config
+        )
+        logger.info("Enabling general kill switch...")
+        future = self.nm_client.add_connection_async(kill_switch.connection)
+        return future
+
+    def remove(self) -> Future:
         """Removes general kill switch from NetworkManager."""
-        raise NotImplementedError
+        connection = self.nm_client.get_connection(HUMAN_READABLE_ID)
+        future = self.nm_client.remove_connection_async(connection)
+        return future
 
     def update(self, server_ip: str):
         """Update the general kill switch."""
         raise NotImplementedError
 
     @property
+    def is_route_killswitch_connection_active(self) -> bool:
+        """Returns if route kill switch is active or not."""
+        return bool(self.nm_client.get_active_connection(ROUTE_HUMAN_READABLE_ID))
+
+    def add_ks_route(self, server_ip: str) -> Future:
+        """Adds route kill switch to NetworkManager"""
+
+        # exclude local network
+        subnets = ip_network("0.0.0.0/0").address_exclude(ip_network(server_ip))
+
+        # merge subnets
+        routes = [ip_route(str(route)) for route in list(subnets)]
+
+        general_config = KillSwitchGeneralConfig(
+            human_readable_id=ROUTE_HUMAN_READABLE_ID,
+            interface_name=ROUTE_INTERFACE_NAME
+        )
+
+        ipv4_config = KillSwitchIPConfig(
+            addresses=["100.85.0.1/24"],
+            dns=["0.0.0.0"],
+            dns_priority=-1400,
+            gateway="100.85.0.1",
+            ignore_auto_dns=True,
+            route_metric=2000,
+            routes=routes
+        )
+
+        ipv6_config = KillSwitchIPConfig(
+            addresses=["fdeb:446c:912d:08da::/64"],
+            dns=["::1"],
+            dns_priority=-1400,
+            gateway="fdeb:446c:912d:08da::1",
+            ignore_auto_dns=True,
+            route_metric=97
+        )
+
+        killswitch = KillSwitchConnection(
+            general_config,
+            ipv4_settings=ipv4_config,
+            ipv6_settings=ipv6_config
+        )
+        future = self.nm_client.add_connection_async(killswitch.connection)
+        return future
+
+    def remove_ks_route(self) -> Future:
+        """Removes route kill switch from NetworkManager."""
+        connection = self.nm_client.get_connection(ROUTE_HUMAN_READABLE_ID)
+        future = self.nm_client.remove_connection_async(connection)
+        return future
+
+    @property
     def is_ipv6_leak_protection_connection_active(self) -> bool:
         """Returns if IPv6 kill switch is active or not."""
         return bool(self.nm_client.get_active_connection(IPV6_HUMAN_READABLE_ID))
@@ -89,7 +168,7 @@ class KillSwitchConnectionHandler:
             dns_priority=-1400,
             gateway="fdeb:446c:912d:08da::1",
             ignore_auto_dns=True,
-            route_metric=97
+            route_metric=95
         )
         killswitch = KillSwitchConnection(
             general_config,
@@ -103,3 +182,4 @@ class KillSwitchConnectionHandler:
         connection = self.nm_client.get_connection(conn_id=IPV6_HUMAN_READABLE_ID)
         future = self.nm_client.remove_connection_async(connection)
         return future
+
diff -rupN original/proton/vpn/killswitch/backend/linux/networkmanager/killswitch_connection.py proton/vpn/killswitch/backend/linux/networkmanager/killswitch_connection.py
--- original/proton/vpn/killswitch/backend/linux/networkmanager/killswitch_connection.py	2023-07-24 11:01:59.000000000 +0700
+++ proton/vpn/killswitch/backend/linux/networkmanager/killswitch_connection.py	2023-07-22 12:50:07.113690747 +0700
@@ -32,14 +32,29 @@ class KillSwitchGeneralConfig:  # pylint
 
 
 @dataclass
+class KillSwitchIPRoute:
+    destination: str
+    hop: str
+    metric: int
+
+
+def ip_route(destination: str, hop: str = None, metric: int = -1) -> KillSwitchIPRoute:
+    return KillSwitchIPRoute(
+        destination,
+        hop,
+        metric
+    )
+
+
+@dataclass
 class KillSwitchIPConfig:  # pylint: disable=missing-class-docstring
     addresses: list
     dns: list
-    dns_priority: str
+    dns_priority: int
     ignore_auto_dns: bool
-    route_metric: str
+    route_metric: int
     gateway: str = None
-    routes: list = field(default_factory=list)
+    routes: list[KillSwitchIPRoute] | list[str] = field(default_factory=list)
 
 
 class KillSwitchConnection:  # pylint: disable=too-few-public-methods
@@ -50,7 +65,7 @@ class KillSwitchConnection:  # pylint: d
     def __init__(
         self,
         general_settings: KillSwitchGeneralConfig,
-        ipv6_settings: KillSwitchIPConfig,
+        ipv6_settings: KillSwitchIPConfig = None,
         ipv4_settings: KillSwitchIPConfig = None
     ):
         self._connection_profile = None
@@ -88,7 +103,7 @@ class KillSwitchConnection:  # pylint: d
         self._connection_profile.add_setting(s_ipv6)
         self._connection_profile.add_setting(s_dummy)
 
-    def _generate_ipv4_settings(self):
+    def _generate_ipv4_settings(self) -> NM.SettingIP4Config:
         """
         For documentaion see:
         https://lazka.github.io/pgi-docs/index.html#NM-1.0/classes/SettingIPConfig.html#NM.SettingIPConfig
@@ -116,11 +131,11 @@ class KillSwitchConnection:  # pylint: d
 
         if self._ipv4_settings.routes:
             for route in self._ipv4_settings.routes:
-                ip, prefix = route.split("/")  # pylint: disable=invalid-name
+                ip, prefix = route.destination.split("/")
                 s_ip4.add_route(
                     NM.IPRoute.new(
                         family=GLib.SYSDEF_AF_INET, dest=ip, prefix=int(prefix),
-                        next_hop=None, metric=-1
+                        next_hop=route.hop, metric=route.metric
                     )
                 )
 
diff -rupN original/proton/vpn/killswitch/backend/linux/networkmanager/nmkillswitch.py proton/vpn/killswitch/backend/linux/networkmanager/nmkillswitch.py
--- original/proton/vpn/killswitch/backend/linux/networkmanager/nmkillswitch.py	2023-07-24 11:01:59.000000000 +0700
+++ proton/vpn/killswitch/backend/linux/networkmanager/nmkillswitch.py	2023-07-24 10:58:19.939486607 +0700
@@ -23,6 +23,9 @@ import sys
 from concurrent.futures import Future
 
 import gi
+
+from proton.vpn.connection import VPNServer
+
 gi.require_version("NM", "1.0")  # noqa: required before importing NM module
 # pylint: disable=wrong-import-position
 from gi.repository import GLib # noqa
@@ -54,27 +57,105 @@ class NMKillSwitch(KillSwitch):
         self._ks_handler = ks_handler or KillSwitchConnectionHandler()
         super().__init__()
 
-    def enable(self, vpn_server):
+    def enable(self) -> Future:
         """Enables general kill switch."""
-        if not self._ks_handler.is_killswitch_connection_active:
-            # Currently we assume the server IP is and IPv4 address.
-            self._ks_handler.add(vpn_server.server_ip)
+        custom_future = Future()
 
-        if not self._ks_handler.is_killswitch_connection_active:
-            raise KillSwitchException("Kill Switch is not running")
+        if self._ks_handler.is_killswitch_connection_active:
+            custom_future.set_result(None)
+            return custom_future
 
-    def disable(self):
+        def _on_killswitch_enabled(_future: Future):
+            try:
+                _future.result()
+                logger.info("Enabled general kill switch...")
+                custom_future.set_result(None)
+            except GLib.GError:
+                traceback = sys.exc_info()[2]
+                custom_future.set_exception(
+                    KillSwitchException(
+                        "Unable to add general kill switch"
+                    ).with_traceback(traceback)
+                )
+        future = self._ks_handler.add()
+        future.add_done_callback(_on_killswitch_enabled)
+        return custom_future
+
+    def disable(self) -> Future:
         """Disables general kill switch."""
-        if self._ks_handler.is_killswitch_connection_active:
-            self._ks_handler.remove()
+        custom_future = Future()
+        if not self._ks_handler.is_killswitch_connection_active:
+            custom_future.set_result(None)
+            return custom_future
 
-        if self._ks_handler.is_killswitch_connection_active:
-            raise KillSwitchException("Kill Switch is not running")
+        def _on_killswitch_disabled(_future: Future):
+            try:
+                _future.result()
+                logger.info("Removed general kill switch...")
+                custom_future.set_result(None)
+            except GLib.GError:
+                traceback = sys.exc_info()[2]
+                custom_future.set_exception(
+                    KillSwitchException(
+                        "Unable to remove general kill switch"
+                    ).with_traceback(traceback)
+                )
+        future = self._ks_handler.remove()
+        future.add_done_callback(_on_killswitch_disabled)
+        return custom_future
 
     def update(self, vpn_server):
         """Currently not being used"""
         raise NotImplementedError
 
+    def enable_route(self, vpn_server: VPNServer) -> Future:
+        """Enables IPv4 kill switch."""
+        custom_future = Future()
+
+        if self._ks_handler.is_route_killswitch_connection_active:
+            custom_future.set_result(None)
+            return custom_future
+
+        def _on_route_enabled(_future: Future):
+            try:
+                _future.result()
+                logger.info("Enabled kill switch route...")
+                custom_future.set_result(None)
+            except GLib.GError:
+                traceback = sys.exc_info()[2]
+                custom_future.set_exception(
+                    KillSwitchException(
+                        "Unable to add kill switch route"
+                    ).with_traceback(traceback)
+                )
+
+        future = self._ks_handler.add_ks_route(vpn_server.server_ip)
+        future.add_done_callback(_on_route_enabled)
+        return custom_future
+
+    def disable_route(self) -> Future:
+        custom_future = Future()
+        if not self._ks_handler.is_route_killswitch_connection_active:
+            custom_future.set_result(None)
+            return custom_future
+
+        def _on_route_disabled(_future: Future):
+            try:
+                _future.result()
+                logger.info("Removed kill switch route...")
+                custom_future.set_result(None)
+            except GLib.GError:
+                traceback = sys.exc_info()[2]
+                custom_future.set_exception(
+                    KillSwitchException(
+                        "Unable to remove kill switch route"
+                    ).with_traceback(traceback)
+                )
+
+        future = self._ks_handler.remove_ks_route()
+        future.add_done_callback(_on_route_disabled)
+        return custom_future
+
     def enable_ipv6_leak_protection(self) -> Future:
         """Enables IPv6 kill switch."""
         custom_future = Future()
@@ -86,6 +167,7 @@ class NMKillSwitch(KillSwitch):
         def _on_ivp6_leak_protection_enabled(_future: Future):
             try:
                 _future.result()
+                logger.info("Enabled ipv6 leak protection...")
                 custom_future.set_result(None)
             except GLib.GError:
                 traceback = sys.exc_info()[2]
@@ -109,6 +191,7 @@ class NMKillSwitch(KillSwitch):
         def _on_ivp6_leak_protection_disabled(_future: Future):
             try:
                 _future.result()
+                logger.info("Removed ipv6 leak protection...")
                 custom_future.set_result(None)
             except GLib.GError:
                 traceback = sys.exc_info()[2]
@@ -117,7 +200,6 @@ class NMKillSwitch(KillSwitch):
                         "Unable to remove IPv6 connection"
                     ).with_traceback(traceback)
                 )
-
         future = self._ks_handler.remove_ipv6_leak_protection()
         future.add_done_callback(_on_ivp6_leak_protection_disabled)
         return custom_future
diff -rupN original/proton/vpn/killswitch/interface/killswitch.py proton/vpn/killswitch/interface/killswitch.py
--- original/proton/vpn/killswitch/interface/killswitch.py	2023-07-24 11:01:59.000000000 +0700
+++ proton/vpn/killswitch/interface/killswitch.py	2023-07-22 10:11:26.973353094 +0700
@@ -47,7 +47,7 @@ class KillSwitch:
         except RuntimeError as excp:
             raise MissingKillSwitchBackendDetails(excp) from excp
 
-    def enable(self, vpn_server):
+    def enable(self):
         """
         Enables the kill switch.
 
@@ -71,7 +71,23 @@ class KillSwitch:
         """
         raise NotImplementedError
 
-    def enable_ipv6_leak_protection(self) -> Future:
+    def enable_route(self, vpn_server):
+        """
+        Enables the kill switch route.
+
+        :raises KillSwitchError: If unable to enable the kill switch route.
+        """
+        raise NotImplementedError
+
+    def disable_route(self):
+        """
+        Disables the kill switch route.
+
+        :raises KillSwitchError: If unable to disable the kill switch route.
+        """
+        raise NotImplementedError
+
+    def enable_ipv6_leak_protection(self):
         """
         Enables IPv6 kill switch to prevent leaks.
 
@@ -79,7 +95,7 @@ class KillSwitch:
         """
         raise NotImplementedError
 
-    def disable_ipv6_leak_protection(self) -> Future:
+    def disable_ipv6_leak_protection(self):
         """
         Disables IPv6 kill switch to prevent leaks.
 
diff -rupN original/proton/vpn/session/client_config.py proton/vpn/session/client_config.py
--- original/proton/vpn/session/client_config.py	2023-07-24 11:01:59.000000000 +0700
+++ proton/vpn/session/client_config.py	2023-07-20 19:29:53.140907883 +0700
@@ -20,10 +20,11 @@ from __future__ import annotations
 from dataclasses import dataclass
 from pathlib import Path
 import random
-from typing import List, Optional, TYPE_CHECKING
+from typing import List, TYPE_CHECKING
 import time
 
 from proton.utils.environment import VPNExecutionEnvironment
+from proton.vpn.core_api.settings import KillSwitchMode
 
 from proton.vpn.session.cache import CacheFile
 from proton.vpn.session.exceptions import ClientConfigDecodeError
@@ -56,6 +57,7 @@ DEFAULT_CLIENT_CONFIG = {
         "StartConnectOnBoot": True,
         "PollNotificationAPI": True,
         "VpnAccelerator": True,
+        "KillSwitch": False,
         "SmartReconnect": True,
         "PromoCode": False,
         "WireGuardTls": True,
@@ -114,6 +116,7 @@ class FeatureFlags:  # pylint: disable=R
     start_connect_on_boot: bool
     poll_notification_api: bool
     vpn_accelerator: bool
+    kill_switch: KillSwitchMode
     smart_reconnect: bool
     promo_code: bool
     wireguard_tls: bool
@@ -134,6 +137,7 @@ class FeatureFlags:  # pylint: disable=R
             feature_flags["StartConnectOnBoot"],
             feature_flags["PollNotificationAPI"],
             feature_flags["VpnAccelerator"],
+            feature_flags["KillSwitch"],
             feature_flags["SmartReconnect"],
             feature_flags["PromoCode"],
             feature_flags["WireGuardTls"],
@@ -171,6 +175,10 @@ class ClientConfig:
             feature_flags = apidata["FeatureFlags"]
             expiration_time = float(apidata.get("ExpirationTime", cls.get_expiration_time()))
 
+            # add 'KillSwitch' flag if it's not present
+            if "KillSwitch" not in feature_flags:
+                feature_flags["KillSwitch"] = KillSwitchMode.DISABLED
+
             return ClientConfig(
                 # No need to copy openvpn_ports, OpenVPNPorts takes care of it.
                 OpenVPNPorts.from_dict(openvpn_ports),
diff -rupN original/proton/vpn/session/credentials.py proton/vpn/session/credentials.py
--- original/proton/vpn/session/credentials.py	2023-07-24 11:01:59.000000000 +0700
+++ proton/vpn/session/credentials.py	2023-07-24 07:10:52.457066157 +0700
@@ -22,6 +22,7 @@ import base64
 from dataclasses import dataclass
 
 from typing import Optional
+
 from proton.vpn.session.certificates import Certificate
 from proton.vpn.session.dataclasses import VPNCertificate
 from proton.vpn.session.exceptions import (VPNCertificateExpiredError,
diff -rupN original/proton/vpn/session/key_mgr.py proton/vpn/session/key_mgr.py
--- original/proton/vpn/session/key_mgr.py	2023-07-24 11:01:59.000000000 +0700
+++ proton/vpn/session/key_mgr.py	2023-07-24 09:21:08.259603304 +0700
@@ -62,7 +62,8 @@ class KeyHandler:
         pem_data = "".join(open(ed25519sk_file).readlines())
         key = serialization.load_pem_private_key(pem_data.encode("ascii"), password=None, backend=backend_default)
         assert isinstance(key, cryptography.hazmat.primitives.asymmetric.ed25519.Ed25519PrivateKey)
-        private_key = key.private_bytes(Encoding.Raw, PrivateFormat.Raw, encryption_algorithm=serialization.NoEncryption())
+        private_key = key.private_bytes(Encoding.Raw, PrivateFormat.Raw,
+                                        encryption_algorithm=serialization.NoEncryption())
         return KeyHandler(private_key=private_key)
 
     @property
@@ -71,7 +72,8 @@ class KeyHandler:
 
     @property
     def ed25519_sk_bytes(self) -> bytes:
-        return self._private_key.private_bytes(Encoding.Raw, PrivateFormat.Raw, encryption_algorithm=serialization.NoEncryption())
+        return self._private_key.private_bytes(Encoding.Raw, PrivateFormat.Raw,
+                                               encryption_algorithm=serialization.NoEncryption())
 
     @property
     def ed25519_pk_bytes(self) -> bytes:
@@ -83,11 +85,13 @@ class KeyHandler:
 
     @property
     def ed25519_sk_pem(self) -> str:
-        return self._private_key.private_bytes(encoding=Encoding.PEM, format=PrivateFormat.PKCS8, encryption_algorithm=serialization.NoEncryption()).decode('ascii')
+        return self._private_key.private_bytes(encoding=Encoding.PEM, format=PrivateFormat.PKCS8,
+                                               encryption_algorithm=serialization.NoEncryption()).decode('ascii')
 
     @property
     def ed25519_pk_pem(self) -> str:
-        return self._public_key.public_bytes(encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo).decode('ascii')
+        return self._public_key.public_bytes(encoding=serialization.Encoding.PEM,
+                                             format=serialization.PublicFormat.SubjectPublicKeyInfo).decode('ascii')
 
     @property
     def x25519_sk_bytes(self) -> bytes:
@@ -108,7 +112,8 @@ class KeyHandler:
     @classmethod
     def __generate_key_pair(cls, private_key=None):
         if private_key:
-            private_key = cryptography.hazmat.primitives.asymmetric.ed25519.Ed25519PrivateKey.from_private_bytes(private_key)
+            private_key = (cryptography.hazmat.primitives.asymmetric
+                           .ed25519.Ed25519PrivateKey.from_private_bytes(private_key))
         else:
             private_key = cryptography.hazmat.primitives.asymmetric.ed25519.Ed25519PrivateKey.generate()
         public_key = private_key.public_key()
